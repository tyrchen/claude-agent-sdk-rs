# Claude Agent SDK for Rust - Implementation Specification

**Version**: 0.1.0
**Based on**: claude-agent-sdk-python v0.1.3
**Target Rust Version**: 1.70+

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Architecture Overview](#architecture-overview)
3. [Core Components](#core-components)
4. [Type System Design](#type-system-design)
5. [Public API Design](#public-api-design)
6. [Internal Implementation](#internal-implementation)
7. [Error Handling](#error-handling)
8. [Async Runtime Strategy](#async-runtime-strategy)
9. [Testing Strategy](#testing-strategy)
10. [Crate Structure](#crate-structure)
11. [Dependencies](#dependencies)
12. [Implementation Phases](#implementation-phases)
13. [Examples & Documentation](#examples--documentation)

---

## 1. Executive Summary

The Claude Agent SDK for Rust provides a Rust interface to interact with Claude Code CLI, enabling developers to build applications that leverage Claude's capabilities programmatically. This specification outlines the complete implementation based on the Python SDK (v0.1.3) architecture.

### Key Features

- **Simple Query Interface**: One-shot queries for stateless interactions
- **Streaming Client**: Bidirectional, stateful conversations with full control
- **Custom Tools (SDK MCP Servers)**: In-process tool definitions callable by Claude
- **Hooks System**: Intercept and control Claude's behavior at runtime
- **Permission Management**: Fine-grained control over tool execution
- **Session Management**: Resume, fork, and manage conversation sessions
- **Transport Abstraction**: Pluggable transport layer for extensibility

---

## 2. Architecture Overview

### 2.1 Layered Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    Public API Layer                     │
│  (query(), ClaudeClient, tool!(), create_sdk_server())  │
└─────────────────────────────────────────────────────────┘
                           │
┌─────────────────────────────────────────────────────────┐
│                  Control Protocol Layer                 │
│        (Query: handles bidirectional control)           │
└─────────────────────────────────────────────────────────┘
                           │
┌─────────────────────────────────────────────────────────┐
│                   Transport Layer                       │
│     (SubprocessTransport, custom implementations)       │
└─────────────────────────────────────────────────────────┘
                           │
┌─────────────────────────────────────────────────────────┐
│                  Claude Code CLI                        │
│         (external process via stdio/subprocess)         │
└─────────────────────────────────────────────────────────┘
```

### 2.2 Data Flow

#### One-shot Query Flow
```
User Code → query() → InternalClient → Transport → CLI → Messages → User Code
```

#### Streaming Client Flow
```
User Code → ClaudeClient::connect() → Transport ↔ CLI
           ↓                                      ↓
    ClaudeClient::query()                    Messages
           ↓                                      ↓
    ClaudeClient::receive_messages() ← Query ← Messages
```

### 2.3 Control Protocol

The SDK implements a bidirectional control protocol with the CLI:

- **Control Requests**: SDK → CLI (initialize, interrupt, set_permission_mode, etc.)
- **Control Responses**: CLI → SDK (success/error responses)
- **Callback Requests**: CLI → SDK (can_use_tool, hook callbacks, MCP requests)
- **Callback Responses**: SDK → CLI (permission decisions, hook outputs, MCP responses)

---

## 3. Core Components

### 3.1 Component Breakdown

| Component       | Purpose          | Key Responsibilities                        |
|-----------------|------------------|---------------------------------------------|
| `query()`       | Simple API       | One-shot queries, stateless                 |
| `ClaudeClient`  | Interactive API  | Bidirectional streaming, session management |
| `Transport`     | I/O abstraction  | Process management, stdio communication     |
| `Query`         | Control protocol | Request/response routing, callback handling |
| `MessageParser` | Serialization    | Parse CLI JSON into typed messages          |
| `Types`         | Type system      | All message, config, and result types       |
| `SdkMcpServer`  | Custom tools     | In-process tool execution                   |
| `Errors`        | Error handling   | Hierarchical error types                    |

---

## 4. Type System Design

### 4.1 Message Types

All messages use strong typing with enums and structs:

```rust
#[derive(Debug, Clone)]
pub enum Message {
    User(UserMessage),
    Assistant(AssistantMessage),
    System(SystemMessage),
    Result(ResultMessage),
    StreamEvent(StreamEvent),
}

#[derive(Debug, Clone)]
pub struct UserMessage {
    pub content: MessageContent,
    pub parent_tool_use_id: Option<String>,
}

#[derive(Debug, Clone)]
pub enum MessageContent {
    Text(String),
    Blocks(Vec<ContentBlock>),
}

#[derive(Debug, Clone)]
pub struct AssistantMessage {
    pub content: Vec<ContentBlock>,
    pub model: String,
    pub parent_tool_use_id: Option<String>,
}

#[derive(Debug, Clone)]
pub struct SystemMessage {
    pub subtype: String,
    pub data: serde_json::Value,
}

#[derive(Debug, Clone)]
pub struct ResultMessage {
    pub subtype: String,
    pub duration_ms: u64,
    pub duration_api_ms: u64,
    pub is_error: bool,
    pub num_turns: u32,
    pub session_id: String,
    pub total_cost_usd: Option<f64>,
    pub usage: Option<serde_json::Value>,
    pub result: Option<String>,
}

#[derive(Debug, Clone)]
pub struct StreamEvent {
    pub uuid: String,
    pub session_id: String,
    pub event: serde_json::Value,
    pub parent_tool_use_id: Option<String>,
}
```

### 4.2 Content Blocks

```rust
#[derive(Debug, Clone)]
pub enum ContentBlock {
    Text(TextBlock),
    Thinking(ThinkingBlock),
    ToolUse(ToolUseBlock),
    ToolResult(ToolResultBlock),
}

#[derive(Debug, Clone)]
pub struct TextBlock {
    pub text: String,
}

#[derive(Debug, Clone)]
pub struct ThinkingBlock {
    pub thinking: String,
    pub signature: String,
}

#[derive(Debug, Clone)]
pub struct ToolUseBlock {
    pub id: String,
    pub name: String,
    pub input: serde_json::Value,
}

#[derive(Debug, Clone)]
pub struct ToolResultBlock {
    pub tool_use_id: String,
    pub content: Option<ToolResultContent>,
    pub is_error: Option<bool>,
}

#[derive(Debug, Clone)]
pub enum ToolResultContent {
    Text(String),
    Blocks(Vec<serde_json::Value>),
}
```

### 4.3 Configuration Types

```rust
#[derive(Debug, Clone, Default)]
pub struct ClaudeAgentOptions {
    pub allowed_tools: Vec<String>,
    pub system_prompt: Option<SystemPrompt>,
    pub mcp_servers: McpServers,
    pub permission_mode: Option<PermissionMode>,
    pub continue_conversation: bool,
    pub resume: Option<String>,
    pub max_turns: Option<u32>,
    pub disallowed_tools: Vec<String>,
    pub model: Option<String>,
    pub permission_prompt_tool_name: Option<String>,
    pub cwd: Option<PathBuf>,
    pub cli_path: Option<PathBuf>,
    pub settings: Option<String>,
    pub add_dirs: Vec<PathBuf>,
    pub env: HashMap<String, String>,
    pub extra_args: HashMap<String, Option<String>>,
    pub max_buffer_size: Option<usize>,
    pub stderr_callback: Option<Box<dyn Fn(String) + Send + Sync>>,
    pub can_use_tool: Option<CanUseToolCallback>,
    pub hooks: Option<HashMap<HookEvent, Vec<HookMatcher>>>,
    pub user: Option<String>,
    pub include_partial_messages: bool,
    pub fork_session: bool,
    pub agents: Option<HashMap<String, AgentDefinition>>,
    pub setting_sources: Option<Vec<SettingSource>>,
}

#[derive(Debug, Clone)]
pub enum SystemPrompt {
    Text(String),
    Preset(SystemPromptPreset),
}

#[derive(Debug, Clone)]
pub struct SystemPromptPreset {
    pub preset: String, // "claude_code"
    pub append: Option<String>,
}

#[derive(Debug, Clone, Copy)]
pub enum PermissionMode {
    Default,
    AcceptEdits,
    Plan,
    BypassPermissions,
}

#[derive(Debug, Clone, Copy)]
pub enum SettingSource {
    User,
    Project,
    Local,
}
```

### 4.4 MCP Server Configuration

```rust
#[derive(Debug, Clone)]
pub enum McpServers {
    Empty,
    Dict(HashMap<String, McpServerConfig>),
    Path(PathBuf),
}

#[derive(Debug, Clone)]
pub enum McpServerConfig {
    Stdio(McpStdioServerConfig),
    Sse(McpSseServerConfig),
    Http(McpHttpServerConfig),
    Sdk(McpSdkServerConfig),
}

#[derive(Debug, Clone)]
pub struct McpStdioServerConfig {
    pub command: String,
    pub args: Option<Vec<String>>,
    pub env: Option<HashMap<String, String>>,
}

#[derive(Debug, Clone)]
pub struct McpSseServerConfig {
    pub url: String,
    pub headers: Option<HashMap<String, String>>,
}

#[derive(Debug, Clone)]
pub struct McpHttpServerConfig {
    pub url: String,
    pub headers: Option<HashMap<String, String>>,
}

#[derive(Debug, Clone)]
pub struct McpSdkServerConfig {
    pub name: String,
    pub instance: Arc<dyn SdkMcpServer>,
}
```

### 4.5 Hook Types

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum HookEvent {
    PreToolUse,
    PostToolUse,
    UserPromptSubmit,
    Stop,
    SubagentStop,
    PreCompact,
}

#[derive(Clone)]
pub struct HookMatcher {
    pub matcher: Option<String>,
    pub hooks: Vec<HookCallback>,
}

pub type HookCallback = Arc<dyn Fn(HookInput, Option<String>, HookContext) -> BoxFuture<'static, HookJsonOutput> + Send + Sync>;

#[derive(Debug, Clone)]
pub enum HookInput {
    PreToolUse(PreToolUseHookInput),
    PostToolUse(PostToolUseHookInput),
    UserPromptSubmit(UserPromptSubmitHookInput),
    Stop(StopHookInput),
    SubagentStop(SubagentStopHookInput),
    PreCompact(PreCompactHookInput),
}

#[derive(Debug, Clone)]
pub struct PreToolUseHookInput {
    pub session_id: String,
    pub transcript_path: String,
    pub cwd: String,
    pub permission_mode: Option<String>,
    pub tool_name: String,
    pub tool_input: serde_json::Value,
}

// Similar structs for other hook types...

#[derive(Debug, Clone)]
pub enum HookJsonOutput {
    Async(AsyncHookJsonOutput),
    Sync(SyncHookJsonOutput),
}

#[derive(Debug, Clone)]
pub struct AsyncHookJsonOutput {
    pub async_timeout: Option<u64>,
}

#[derive(Debug, Clone, Default)]
pub struct SyncHookJsonOutput {
    pub continue_: Option<bool>,
    pub suppress_output: Option<bool>,
    pub stop_reason: Option<String>,
    pub decision: Option<String>,
    pub system_message: Option<String>,
    pub reason: Option<String>,
    pub hook_specific_output: Option<HookSpecificOutput>,
}

#[derive(Debug, Clone)]
pub enum HookSpecificOutput {
    PreToolUse(PreToolUseHookSpecificOutput),
    PostToolUse(PostToolUseHookSpecificOutput),
    UserPromptSubmit(UserPromptSubmitHookSpecificOutput),
}

#[derive(Debug, Clone, Default)]
pub struct PreToolUseHookSpecificOutput {
    pub permission_decision: Option<String>,
    pub permission_decision_reason: Option<String>,
    pub updated_input: Option<serde_json::Value>,
}
```

### 4.6 Permission Types

```rust
pub type CanUseToolCallback = Arc<dyn Fn(String, serde_json::Value, ToolPermissionContext) -> BoxFuture<'static, PermissionResult> + Send + Sync>;

#[derive(Debug, Clone)]
pub struct ToolPermissionContext {
    pub signal: Option<()>, // Future: abort signal support
    pub suggestions: Vec<PermissionUpdate>,
}

#[derive(Debug, Clone)]
pub enum PermissionResult {
    Allow(PermissionResultAllow),
    Deny(PermissionResultDeny),
}

#[derive(Debug, Clone, Default)]
pub struct PermissionResultAllow {
    pub updated_input: Option<serde_json::Value>,
    pub updated_permissions: Option<Vec<PermissionUpdate>>,
}

#[derive(Debug, Clone, Default)]
pub struct PermissionResultDeny {
    pub message: String,
    pub interrupt: bool,
}

#[derive(Debug, Clone)]
pub struct PermissionUpdate {
    pub type_: PermissionUpdateType,
    pub rules: Option<Vec<PermissionRuleValue>>,
    pub behavior: Option<PermissionBehavior>,
    pub mode: Option<PermissionMode>,
    pub directories: Option<Vec<String>>,
    pub destination: Option<PermissionUpdateDestination>,
}

#[derive(Debug, Clone, Copy)]
pub enum PermissionUpdateType {
    AddRules,
    ReplaceRules,
    RemoveRules,
    SetMode,
    AddDirectories,
    RemoveDirectories,
}

#[derive(Debug, Clone)]
pub struct PermissionRuleValue {
    pub tool_name: String,
    pub rule_content: Option<String>,
}

#[derive(Debug, Clone, Copy)]
pub enum PermissionBehavior {
    Allow,
    Deny,
    Ask,
}

#[derive(Debug, Clone, Copy)]
pub enum PermissionUpdateDestination {
    UserSettings,
    ProjectSettings,
    LocalSettings,
    Session,
}
```

### 4.7 Agent Definition

```rust
#[derive(Debug, Clone)]
pub struct AgentDefinition {
    pub description: String,
    pub prompt: String,
    pub tools: Option<Vec<String>>,
    pub model: Option<AgentModel>,
}

#[derive(Debug, Clone, Copy)]
pub enum AgentModel {
    Sonnet,
    Opus,
    Haiku,
    Inherit,
}
```

---

## 5. Public API Design

### 5.1 Simple Query Function

```rust
/// One-shot query for stateless interactions
pub async fn query(
    prompt: impl Into<QueryPrompt>,
    options: Option<ClaudeAgentOptions>,
) -> Result<impl Stream<Item = Result<Message>>> {
    // Implementation delegates to InternalClient
}

pub enum QueryPrompt {
    Text(String),
    Stream(Pin<Box<dyn Stream<Item = serde_json::Value> + Send>>),
}
```

**Example Usage:**
```rust
use claude_agent_sdk_rs::{query, Message};
use futures::StreamExt;

#[tokio::main]
async fn main() -> Result<()> {
    let mut messages = query("What is 2 + 2?", None).await?;

    while let Some(message) = messages.next().await {
        match message? {
            Message::Assistant(msg) => {
                for block in msg.content {
                    if let ContentBlock::Text(text) = block {
                        println!("Claude: {}", text.text);
                    }
                }
            }
            _ => {}
        }
    }

    Ok(())
}
```

### 5.2 ClaudeClient (Streaming/Bidirectional)

```rust
pub struct ClaudeClient {
    // Internal state
}

impl ClaudeClient {
    /// Create a new client with options
    pub fn new(options: ClaudeAgentOptions) -> Self;

    /// Create with custom transport
    pub fn with_transport(
        options: ClaudeAgentOptions,
        transport: Box<dyn Transport>,
    ) -> Self;

    /// Connect to Claude (async context manager pattern)
    pub async fn connect(&mut self) -> Result<()>;

    /// Send a query message
    pub async fn query(
        &mut self,
        prompt: impl Into<QueryPrompt>,
        session_id: Option<&str>,
    ) -> Result<()>;

    /// Receive all messages as a stream
    pub fn receive_messages(&mut self) -> impl Stream<Item = Result<Message>> + '_;

    /// Receive messages until ResultMessage
    pub fn receive_response(&mut self) -> impl Stream<Item = Result<Message>> + '_;

    /// Send interrupt signal
    pub async fn interrupt(&mut self) -> Result<()>;

    /// Change permission mode
    pub async fn set_permission_mode(&mut self, mode: PermissionMode) -> Result<()>;

    /// Change AI model
    pub async fn set_model(&mut self, model: Option<&str>) -> Result<()>;

    /// Get server initialization info
    pub async fn get_server_info(&self) -> Option<&serde_json::Value>;

    /// Disconnect from Claude
    pub async fn disconnect(&mut self) -> Result<()>;
}

// RAII pattern for auto-disconnect
impl Drop for ClaudeClient {
    fn drop(&mut self) {
        // Schedule disconnect on drop
    }
}
```

**Example Usage:**
```rust
use claude_agent_sdk_rs::{ClaudeClient, ClaudeAgentOptions, Message};
use futures::StreamExt;

#[tokio::main]
async fn main() -> Result<()> {
    let options = ClaudeAgentOptions::default();
    let mut client = ClaudeClient::new(options);

    client.connect().await?;

    client.query("Hello Claude!", None).await?;

    let mut response = client.receive_response();
    while let Some(message) = response.next().await {
        match message? {
            Message::Assistant(msg) => {
                // Process assistant message
            }
            Message::Result(result) => {
                println!("Cost: ${:.4}", result.total_cost_usd.unwrap_or(0.0));
            }
            _ => {}
        }
    }

    client.disconnect().await?;
    Ok(())
}
```

### 5.3 SDK MCP Server (Custom Tools)

```rust
/// Define a tool handler
pub trait ToolHandler: Send + Sync {
    fn handle(&self, args: serde_json::Value) -> BoxFuture<'static, Result<ToolResult>>;
}

#[derive(Debug, Clone)]
pub struct ToolResult {
    pub content: Vec<ToolResultContent>,
    pub is_error: bool,
}

#[derive(Debug, Clone)]
pub enum ToolResultContent {
    Text { text: String },
    Image { data: String, mime_type: String },
}

/// Macro to define tools ergonomically
#[macro_export]
macro_rules! tool {
    ($name:expr, $desc:expr, $schema:expr, $handler:expr) => {
        SdkMcpTool {
            name: $name.to_string(),
            description: $desc.to_string(),
            input_schema: $schema,
            handler: Arc::new($handler),
        }
    };
}

pub struct SdkMcpTool {
    pub name: String,
    pub description: String,
    pub input_schema: serde_json::Value,
    pub handler: Arc<dyn ToolHandler>,
}

/// Create an in-process MCP server
pub fn create_sdk_mcp_server(
    name: impl Into<String>,
    version: impl Into<String>,
    tools: Vec<SdkMcpTool>,
) -> McpSdkServerConfig;

/// Trait for SDK MCP server implementations
#[async_trait]
pub trait SdkMcpServer: Send + Sync {
    async fn handle_message(&self, message: serde_json::Value) -> Result<serde_json::Value>;
}
```

**Example Usage:**
```rust
use claude_agent_sdk_rs::{tool, create_sdk_mcp_server, ClaudeAgentOptions, ToolResult, ToolResultContent};
use serde_json::json;

async fn greet_handler(args: serde_json::Value) -> Result<ToolResult> {
    let name = args["name"].as_str().unwrap_or("World");
    Ok(ToolResult {
        content: vec![ToolResultContent::Text {
            text: format!("Hello, {}!", name),
        }],
        is_error: false,
    })
}

#[tokio::main]
async fn main() -> Result<()> {
    let greet_tool = tool!(
        "greet",
        "Greet a user",
        json!({
            "type": "object",
            "properties": {
                "name": { "type": "string" }
            },
            "required": ["name"]
        }),
        greet_handler
    );

    let server = create_sdk_mcp_server("my-tools", "1.0.0", vec![greet_tool]);

    let mut servers = HashMap::new();
    servers.insert("tools".to_string(), McpServerConfig::Sdk(server));

    let options = ClaudeAgentOptions {
        mcp_servers: McpServers::Dict(servers),
        allowed_tools: vec!["mcp__tools__greet".to_string()],
        ..Default::default()
    };

    // Use with client...
    Ok(())
}
```

### 5.4 Hooks System

```rust
/// Example hook callback
pub async fn check_bash_command(
    input: HookInput,
    tool_use_id: Option<String>,
    context: HookContext,
) -> HookJsonOutput {
    match input {
        HookInput::PreToolUse(pre_tool) if pre_tool.tool_name == "Bash" => {
            let command = pre_tool.tool_input["command"].as_str().unwrap_or("");
            if command.contains("rm -rf") {
                HookJsonOutput::Sync(SyncHookJsonOutput {
                    hook_specific_output: Some(HookSpecificOutput::PreToolUse(
                        PreToolUseHookSpecificOutput {
                            permission_decision: Some("deny".to_string()),
                            permission_decision_reason: Some("Dangerous command blocked".to_string()),
                            ..Default::default()
                        }
                    )),
                    ..Default::default()
                })
            } else {
                HookJsonOutput::Sync(SyncHookJsonOutput::default())
            }
        }
        _ => HookJsonOutput::Sync(SyncHookJsonOutput::default()),
    }
}

// Usage
let mut hooks = HashMap::new();
hooks.insert(
    HookEvent::PreToolUse,
    vec![HookMatcher {
        matcher: Some("Bash".to_string()),
        hooks: vec![Arc::new(check_bash_command)],
    }],
);

let options = ClaudeAgentOptions {
    hooks: Some(hooks),
    ..Default::default()
};
```

---

## 6. Internal Implementation

### 6.1 Transport Trait

```rust
#[async_trait]
pub trait Transport: Send + Sync {
    /// Connect the transport
    async fn connect(&mut self) -> Result<()>;

    /// Write raw data
    async fn write(&mut self, data: &str) -> Result<()>;

    /// Read messages as a stream
    fn read_messages(&mut self) -> Pin<Box<dyn Stream<Item = Result<serde_json::Value>> + Send + '_>>;

    /// Close the transport
    async fn close(&mut self) -> Result<()>;

    /// Check if ready
    fn is_ready(&self) -> bool;

    /// End input stream (close stdin)
    async fn end_input(&mut self) -> Result<()>;
}
```

### 6.2 SubprocessTransport Implementation

```rust
pub struct SubprocessTransport {
    cli_path: PathBuf,
    cwd: Option<PathBuf>,
    options: ClaudeAgentOptions,
    process: Option<Child>,
    stdin: Option<ChildStdin>,
    stdout: Option<BufReader<ChildStdout>>,
    stderr_task: Option<JoinHandle<()>>,
    ready: bool,
    max_buffer_size: usize,
}

impl SubprocessTransport {
    pub fn new(
        prompt: QueryPrompt,
        options: ClaudeAgentOptions,
    ) -> Self {
        // Build CLI command args from options
    }

    fn find_cli() -> Result<PathBuf> {
        // Search for claude CLI in common locations
    }

    fn build_command(&self) -> Vec<String> {
        // Build CLI args from options
    }

    async fn check_claude_version(&self) -> Result<()> {
        // Version check with warning
    }

    async fn handle_stderr(&self, stderr: ChildStderr) {
        // Read stderr and invoke callbacks
    }
}

#[async_trait]
impl Transport for SubprocessTransport {
    async fn connect(&mut self) -> Result<()> {
        // Start subprocess with proper env vars
        // Set up stdin/stdout/stderr streams
        // Start stderr handler task
    }

    async fn write(&mut self, data: &str) -> Result<()> {
        // Write to stdin with error handling
    }

    fn read_messages(&mut self) -> Pin<Box<dyn Stream<Item = Result<serde_json::Value>> + Send + '_>> {
        // Stream that:
        // 1. Reads stdout line by line
        // 2. Buffers partial JSON
        // 3. Parses complete JSON objects
        // 4. Enforces max buffer size
        // 5. Handles process exit codes
    }

    async fn close(&mut self) -> Result<()> {
        // Clean shutdown:
        // 1. Cancel stderr task
        // 2. Close stdin
        // 3. Terminate process
        // 4. Wait for process exit
    }

    fn is_ready(&self) -> bool {
        self.ready
    }

    async fn end_input(&mut self) -> Result<()> {
        // Close stdin
    }
}
```

### 6.3 Query (Control Protocol Handler)

```rust
pub struct Query {
    transport: Box<dyn Transport>,
    is_streaming_mode: bool,
    can_use_tool: Option<CanUseToolCallback>,
    hooks: HashMap<String, Vec<HookMatcherInternal>>,
    sdk_mcp_servers: HashMap<String, Arc<dyn SdkMcpServer>>,

    // Control protocol state
    pending_control_responses: HashMap<String, oneshot::Sender<ControlResponseResult>>,
    hook_callbacks: HashMap<String, HookCallback>,
    next_callback_id: AtomicU64,
    request_counter: AtomicU64,

    // Message channels
    message_tx: mpsc::UnboundedSender<serde_json::Value>,
    message_rx: mpsc::UnboundedReceiver<serde_json::Value>,

    // Task management
    read_task: Option<JoinHandle<()>>,
    initialized: bool,
    closed: AtomicBool,
    initialization_result: Option<serde_json::Value>,
}

impl Query {
    pub fn new(
        transport: Box<dyn Transport>,
        is_streaming_mode: bool,
        can_use_tool: Option<CanUseToolCallback>,
        hooks: Option<HashMap<String, Vec<HookMatcherInternal>>>,
        sdk_mcp_servers: HashMap<String, Arc<dyn SdkMcpServer>>,
    ) -> Self;

    pub async fn initialize(&mut self) -> Result<Option<serde_json::Value>>;

    pub async fn start(&mut self) -> Result<()>;

    async fn read_messages_task(&mut self);

    async fn handle_control_request(&self, request: SdkControlRequest) -> Result<()>;

    async fn send_control_request(&self, request: serde_json::Value) -> Result<serde_json::Value>;

    async fn handle_sdk_mcp_request(
        &self,
        server_name: &str,
        message: serde_json::Value,
    ) -> Result<serde_json::Value>;

    pub async fn interrupt(&self) -> Result<()>;

    pub async fn set_permission_mode(&self, mode: PermissionMode) -> Result<()>;

    pub async fn set_model(&self, model: Option<&str>) -> Result<()>;

    pub async fn stream_input(&mut self, stream: impl Stream<Item = serde_json::Value>) -> Result<()>;

    pub fn receive_messages(&mut self) -> impl Stream<Item = Result<serde_json::Value>> + '_;

    pub async fn close(&mut self) -> Result<()>;
}
```

### 6.4 InternalClient

```rust
pub struct InternalClient;

impl InternalClient {
    pub async fn process_query(
        prompt: QueryPrompt,
        options: ClaudeAgentOptions,
        transport: Option<Box<dyn Transport>>,
    ) -> Result<impl Stream<Item = Result<Message>>> {
        // 1. Validate options (can_use_tool requires streaming)
        // 2. Create or use provided transport
        // 3. Connect transport
        // 4. Extract SDK MCP servers
        // 5. Create Query
        // 6. Start reading
        // 7. Initialize if streaming
        // 8. Stream input if AsyncIterable
        // 9. Return message stream with cleanup
    }

    fn convert_hooks_to_internal_format(
        hooks: HashMap<HookEvent, Vec<HookMatcher>>,
    ) -> HashMap<String, Vec<HookMatcherInternal>>;
}
```

### 6.5 MessageParser

```rust
pub struct MessageParser;

impl MessageParser {
    pub fn parse(data: serde_json::Value) -> Result<Message> {
        // Match on message type field
        // Parse into appropriate Message variant
        // Validate required fields
        // Return typed message or error
    }

    fn parse_content_block(block: &serde_json::Value) -> Result<ContentBlock>;

    fn parse_user_message(data: &serde_json::Value) -> Result<UserMessage>;

    fn parse_assistant_message(data: &serde_json::Value) -> Result<AssistantMessage>;

    fn parse_system_message(data: &serde_json::Value) -> Result<SystemMessage>;

    fn parse_result_message(data: &serde_json::Value) -> Result<ResultMessage>;

    fn parse_stream_event(data: &serde_json::Value) -> Result<StreamEvent>;
}
```

---

## 7. Error Handling

### 7.1 Error Hierarchy

```rust
#[derive(Debug, thiserror::Error)]
pub enum ClaudeError {
    #[error("CLI connection error: {0}")]
    Connection(#[from] ConnectionError),

    #[error("Process error: {0}")]
    Process(#[from] ProcessError),

    #[error("JSON decode error: {0}")]
    JsonDecode(#[from] JsonDecodeError),

    #[error("Message parse error: {0}")]
    MessageParse(#[from] MessageParseError),

    #[error("Transport error: {0}")]
    Transport(String),

    #[error("Control protocol error: {0}")]
    ControlProtocol(String),

    #[error("Invalid configuration: {0}")]
    InvalidConfig(String),

    #[error(transparent)]
    Other(#[from] anyhow::Error),
}

#[derive(Debug, thiserror::Error)]
#[error("CLI not found: {message}")]
pub struct CliNotFoundError {
    pub message: String,
    pub cli_path: Option<PathBuf>,
}

#[derive(Debug, thiserror::Error)]
#[error("Connection error: {message}")]
pub struct ConnectionError {
    pub message: String,
}

#[derive(Debug, thiserror::Error)]
#[error("Process error (exit code {exit_code:?}): {message}")]
pub struct ProcessError {
    pub message: String,
    pub exit_code: Option<i32>,
    pub stderr: Option<String>,
}

#[derive(Debug, thiserror::Error)]
#[error("JSON decode error: {message}")]
pub struct JsonDecodeError {
    pub message: String,
    pub line: String,
}

#[derive(Debug, thiserror::Error)]
#[error("Message parse error: {message}")]
pub struct MessageParseError {
    pub message: String,
    pub data: Option<serde_json::Value>,
}

pub type Result<T> = std::result::Result<T, ClaudeError>;
```

---

## 8. Async Runtime Strategy

### 8.1 Runtime Choice

**Primary**: Use **tokio** as the default async runtime

**Rationale**:
- Most popular Rust async runtime
- Excellent subprocess support
- Good ecosystem compatibility
- Mature and stable

### 8.2 Runtime Agnostic Design

Where possible, use runtime-agnostic abstractions:

```rust
// Use tokio::process but expose generic traits
pub trait AsyncProcess: Send + Sync {
    // ...
}

// Allow custom runtime implementations
pub trait Runtime: Send + Sync {
    type Process: AsyncProcess;

    fn spawn_process(&self, cmd: Command) -> Result<Self::Process>;
    fn spawn_task(&self, fut: impl Future + Send + 'static);
}
```

### 8.3 Feature Flags

```toml
[features]
default = ["tokio-runtime"]
tokio-runtime = ["tokio"]
async-std-runtime = ["async-std"]
```

---

## 9. Testing Strategy

### 9.1 Unit Tests

- Test each component in isolation
- Mock transport for Query tests
- Test message parsing thoroughly
- Test error handling paths

### 9.2 Integration Tests

```rust
#[tokio::test]
async fn test_simple_query() {
    let result = query("What is 2+2?", None).await.unwrap();
    // Verify response structure
}

#[tokio::test]
async fn test_streaming_client() {
    let mut client = ClaudeClient::new(ClaudeAgentOptions::default());
    client.connect().await.unwrap();
    client.query("Hello", None).await.unwrap();
    // Verify bidirectional communication
}

#[tokio::test]
async fn test_sdk_mcp_server() {
    // Test in-process tool execution
}

#[tokio::test]
async fn test_hooks() {
    // Test hook callback invocation
}
```

### 9.3 E2E Tests

- Require Claude Code CLI installed
- Test against actual CLI process
- Use fixtures for reproducible tests
- Test error scenarios (CLI not found, version mismatch, etc.)

### 9.4 Test Fixtures

Create mock CLI outputs for testing:

```json
{"type": "assistant", "message": {"content": [{"type": "text", "text": "Hello!"}], "model": "claude-sonnet-4"}}
{"type": "result", "subtype": "final", "duration_ms": 1000, ...}
```

---

## 10. Crate Structure

```
claude-agent-sdk/
├── Cargo.toml
├── src/
│   ├── lib.rs                 # Public API exports
│   ├── client.rs              # ClaudeClient implementation
│   ├── query.rs               # query() function
│   ├── types/
│   │   ├── mod.rs
│   │   ├── messages.rs        # Message types
│   │   ├── config.rs          # ClaudeAgentOptions
│   │   ├── hooks.rs           # Hook types
│   │   ├── permissions.rs     # Permission types
│   │   └── mcp.rs             # MCP types
│   ├── internal/
│   │   ├── mod.rs
│   │   ├── client.rs          # InternalClient
│   │   ├── query.rs           # Query (control protocol)
│   │   ├── message_parser.rs  # MessageParser
│   │   └── transport/
│   │       ├── mod.rs
│   │       ├── trait.rs       # Transport trait
│   │       └── subprocess.rs  # SubprocessTransport
│   ├── mcp/
│   │   ├── mod.rs
│   │   ├── server.rs          # SdkMcpServer trait
│   │   ├── tool.rs            # Tool definitions
│   │   └── macros.rs          # tool! macro
│   ├── errors.rs              # Error types
│   └── version.rs             # Version info
├── tests/
│   ├── integration_tests.rs
│   ├── e2e_tests.rs
│   └── fixtures/
└── examples/
    ├── quick_start.rs
    ├── streaming_client.rs
    ├── custom_tools.rs
    ├── hooks.rs
    └── permission_callbacks.rs
```

---

## 11. Dependencies

### 11.1 Core Dependencies

```toml
[dependencies]
# Async runtime
tokio = { version = "1.35", features = ["full"] }

# Async traits
async-trait = "0.1"
futures = "0.3"
pin-project = "1.1"

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Error handling
thiserror = "1.0"
anyhow = "1.0"

# Process management
tokio-process = "0.2"

# Path utilities
path-absolutize = "3.1"

# Logging
log = "0.4"
tracing = "0.1"

# MCP integration (if exists)
# mcp = "0.1"

[dev-dependencies]
tokio-test = "0.4"
mockall = "0.12"
proptest = "1.4"
```

### 11.2 Optional Dependencies

```toml
[dependencies.async-std]
version = "1.12"
optional = true

[features]
tokio-runtime = ["tokio"]
async-std-runtime = ["async-std"]
```

---

## 12. Implementation Phases

### Phase 1: Foundation (Week 1-2)
- [ ] Set up project structure
- [ ] Define core types (messages, config, errors)
- [ ] Implement Transport trait and SubprocessTransport
- [ ] Basic subprocess management
- [ ] JSON parsing and message parser

### Phase 2: Simple Query API (Week 3)
- [ ] Implement `query()` function
- [ ] InternalClient implementation
- [ ] Basic error handling
- [ ] Unit tests for transport and parsing
- [ ] Simple integration test

### Phase 3: Control Protocol (Week 4-5)
- [ ] Implement Query (control protocol handler)
- [ ] Request/response routing
- [ ] Initialize handshake
- [ ] Control request types (interrupt, set_permission_mode, etc.)
- [ ] Testing control protocol

### Phase 4: ClaudeClient (Week 6)
- [ ] Implement ClaudeClient
- [ ] Bidirectional streaming
- [ ] Session management
- [ ] Integration tests for streaming

### Phase 5: Hooks System (Week 7)
- [ ] Hook types and callbacks
- [ ] Hook registration and dispatch
- [ ] Hook-specific outputs
- [ ] Testing hooks

### Phase 6: Permission System (Week 8)
- [ ] can_use_tool callback
- [ ] Permission updates
- [ ] Permission context
- [ ] Testing permissions

### Phase 7: SDK MCP Servers (Week 9-10)
- [ ] SdkMcpServer trait
- [ ] Tool definition and registration
- [ ] tool! macro
- [ ] create_sdk_mcp_server function
- [ ] MCP message routing
- [ ] Testing custom tools

### Phase 8: Polish & Documentation (Week 11-12)
- [ ] Comprehensive examples
- [ ] API documentation
- [ ] Integration with mcp crate (if available)
- [ ] Performance optimization
- [ ] Error message improvement
- [ ] E2E tests
- [ ] README and guides

---

## 13. Examples & Documentation

### 13.1 Quick Start Example

```rust
//! examples/quick_start.rs

use claude_agent_sdk_rs::{query, Message, ContentBlock, ClaudeAgentOptions};
use futures::StreamExt;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Basic query
    println!("=== Basic Example ===");
    let mut messages = query("What is 2 + 2?", None).await?;

    while let Some(message) = messages.next().await {
        match message? {
            Message::Assistant(msg) => {
                for block in msg.content {
                    if let ContentBlock::Text(text) = block {
                        println!("Claude: {}", text.text);
                    }
                }
            }
            _ => {}
        }
    }

    // With options
    println!("\n=== With Options Example ===");
    let options = ClaudeAgentOptions {
        system_prompt: Some("You are a helpful assistant".into()),
        max_turns: Some(1),
        ..Default::default()
    };

    let mut messages = query("Explain Rust in one sentence", Some(options)).await?;
    while let Some(message) = messages.next().await {
        if let Message::Assistant(msg) = message? {
            for block in msg.content {
                if let ContentBlock::Text(text) = block {
                    println!("Claude: {}", text.text);
                }
            }
        }
    }

    Ok(())
}
```

### 13.2 Streaming Client Example

```rust
//! examples/streaming_client.rs

use claude_agent_sdk_rs::{ClaudeClient, ClaudeAgentOptions, Message, ContentBlock};
use futures::StreamExt;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let options = ClaudeAgentOptions::default();
    let mut client = ClaudeClient::new(options);

    // Connect
    client.connect().await?;
    println!("Connected to Claude");

    // First query
    client.query("What's your name?", None).await?;

    let mut response = client.receive_response();
    while let Some(message) = response.next().await {
        if let Message::Assistant(msg) = message? {
            for block in msg.content {
                if let ContentBlock::Text(text) = block {
                    println!("Claude: {}", text.text);
                }
            }
        }
    }

    // Follow-up query
    client.query("Tell me a joke", None).await?;

    let mut response = client.receive_response();
    while let Some(message) = response.next().await {
        if let Message::Assistant(msg) = message? {
            for block in msg.content {
                if let ContentBlock::Text(text) = block {
                    println!("Claude: {}", text.text);
                }
            }
        }
    }

    // Clean disconnect
    client.disconnect().await?;
    Ok(())
}
```

### 13.3 Custom Tools Example

```rust
//! examples/custom_tools.rs

use claude_agent_sdk_rs::{
    tool, create_sdk_mcp_server, ClaudeClient, ClaudeAgentOptions,
    McpServers, McpServerConfig, ToolResult, ToolResultContent,
};
use serde_json::json;
use std::collections::HashMap;
use futures::StreamExt;

async fn add_handler(args: serde_json::Value) -> anyhow::Result<ToolResult> {
    let a = args["a"].as_f64().unwrap_or(0.0);
    let b = args["b"].as_f64().unwrap_or(0.0);

    Ok(ToolResult {
        content: vec![ToolResultContent::Text {
            text: format!("Result: {}", a + b),
        }],
        is_error: false,
    })
}

async fn multiply_handler(args: serde_json::Value) -> anyhow::Result<ToolResult> {
    let a = args["a"].as_f64().unwrap_or(0.0);
    let b = args["b"].as_f64().unwrap_or(0.0);

    Ok(ToolResult {
        content: vec![ToolResultContent::Text {
            text: format!("Result: {}", a * b),
        }],
        is_error: false,
    })
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let add_tool = tool!(
        "add",
        "Add two numbers",
        json!({
            "type": "object",
            "properties": {
                "a": { "type": "number" },
                "b": { "type": "number" }
            },
            "required": ["a", "b"]
        }),
        add_handler
    );

    let multiply_tool = tool!(
        "multiply",
        "Multiply two numbers",
        json!({
            "type": "object",
            "properties": {
                "a": { "type": "number" },
                "b": { "type": "number" }
            },
            "required": ["a", "b"]
        }),
        multiply_handler
    );

    let server = create_sdk_mcp_server(
        "calculator",
        "1.0.0",
        vec![add_tool, multiply_tool],
    );

    let mut servers = HashMap::new();
    servers.insert("calc".to_string(), McpServerConfig::Sdk(server));

    let options = ClaudeAgentOptions {
        mcp_servers: McpServers::Dict(servers),
        allowed_tools: vec![
            "mcp__calc__add".to_string(),
            "mcp__calc__multiply".to_string(),
        ],
        ..Default::default()
    };

    let mut client = ClaudeClient::new(options);
    client.connect().await?;

    client.query("What is 5 + 3?", None).await?;

    let mut response = client.receive_response();
    while let Some(message) = response.next().await {
        println!("{:?}", message?);
    }

    client.disconnect().await?;
    Ok(())
}
```

### 13.4 Hooks Example

```rust
//! examples/hooks.rs

use claude_agent_sdk_rs::{
    ClaudeClient, ClaudeAgentOptions, HookEvent, HookMatcher,
    HookInput, HookContext, HookJsonOutput, SyncHookJsonOutput,
    HookSpecificOutput, PreToolUseHookSpecificOutput,
};
use std::collections::HashMap;
use std::sync::Arc;

async fn check_bash_command(
    input: HookInput,
    _tool_use_id: Option<String>,
    _context: HookContext,
) -> HookJsonOutput {
    match input {
        HookInput::PreToolUse(pre_tool) if pre_tool.tool_name == "Bash" => {
            let command = pre_tool.tool_input["command"].as_str().unwrap_or("");

            // Block dangerous commands
            if command.contains("rm -rf /") {
                return HookJsonOutput::Sync(SyncHookJsonOutput {
                    hook_specific_output: Some(HookSpecificOutput::PreToolUse(
                        PreToolUseHookSpecificOutput {
                            permission_decision: Some("deny".to_string()),
                            permission_decision_reason: Some(
                                "Dangerous command blocked".to_string()
                            ),
                            ..Default::default()
                        }
                    )),
                    ..Default::default()
                });
            }
        }
        _ => {}
    }

    HookJsonOutput::Sync(SyncHookJsonOutput::default())
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let mut hooks = HashMap::new();
    hooks.insert(
        HookEvent::PreToolUse,
        vec![HookMatcher {
            matcher: Some("Bash".to_string()),
            hooks: vec![Arc::new(check_bash_command)],
        }],
    );

    let options = ClaudeAgentOptions {
        allowed_tools: vec!["Bash".to_string()],
        hooks: Some(hooks),
        ..Default::default()
    };

    let mut client = ClaudeClient::new(options);
    client.connect().await?;

    // This will be blocked
    client.query("Run: rm -rf /", None).await?;
    // Process messages...

    // This will be allowed
    client.query("Run: echo 'Hello'", None).await?;
    // Process messages...

    client.disconnect().await?;
    Ok(())
}
```

### 13.5 API Documentation Guidelines

- Use `///` doc comments for all public items
- Include examples in doc comments
- Document error conditions
- Link related types
- Provide usage guidelines

Example:
```rust
/// Query Claude Code for one-shot or unidirectional streaming interactions.
///
/// This function is ideal for simple, stateless queries where you don't need
/// bidirectional communication or conversation management. For interactive,
/// stateful conversations, use [`ClaudeClient`] instead.
///
/// # Examples
///
/// Basic query:
/// ```no_run
/// use claude_agent_sdk_rs::query;
/// use futures::StreamExt;
///
/// #[tokio::main]
/// async fn main() -> anyhow::Result<()> {
///     let mut messages = query("What is 2 + 2?", None).await?;
///     while let Some(message) = messages.next().await {
///         println!("{:?}", message?);
///     }
///     Ok(())
/// }
/// ```
///
/// # Errors
///
/// Returns [`ClaudeError`] if:
/// - Claude Code CLI is not found
/// - The CLI process fails to start
/// - The CLI returns an error
/// - JSON parsing fails
///
/// # See Also
///
/// - [`ClaudeClient`] for interactive conversations
/// - [`ClaudeAgentOptions`] for configuration options
pub async fn query(
    prompt: impl Into<QueryPrompt>,
    options: Option<ClaudeAgentOptions>,
) -> Result<impl Stream<Item = Result<Message>>> {
    // ...
}
```

---

## 14. Additional Considerations

### 14.1 Minimum Claude Code Version

- Check version on startup (like Python SDK)
- Minimum required: 2.0.0
- Warn if version is too old
- Allow skip via environment variable: `CLAUDE_AGENT_SDK_SKIP_VERSION_CHECK`

### 14.2 Environment Variables

Set on subprocess:
- `CLAUDE_CODE_ENTRYPOINT=sdk-rs`
- `CLAUDE_AGENT_SDK_VERSION=<version>`

### 14.3 Graceful Shutdown

- Implement Drop for ClaudeClient
- Clean up subprocess on drop
- Close all streams properly
- Cancel background tasks

### 14.4 Performance Optimizations

- Use buffered I/O for subprocess streams
- Minimize allocations in hot paths
- Consider using `bytes` crate for zero-copy
- Profile message parsing

### 14.5 Security Considerations

- Sanitize CLI arguments
- Validate JSON inputs
- Don't log sensitive data
- Secure subprocess environment

### 14.6 Backwards Compatibility

- Use semantic versioning
- Deprecate before removing APIs
- Document breaking changes
- Provide migration guides

---

## 15. Open Questions & Future Work

### 15.1 Open Questions

1. **MCP Integration**: Should we depend on an existing Rust MCP crate or implement our own minimal version?
2. **Runtime Flexibility**: How important is supporting async-std vs tokio-only?
3. **Builder Pattern**: Should ClaudeAgentOptions use a builder pattern for ergonomics?
4. **Macro Hygiene**: How complex should the `tool!` macro be?

### 15.2 Future Enhancements

- WebSocket transport for remote Claude Code
- gRPC transport option
- Built-in retry logic
- Rate limiting support
- Metrics and telemetry hooks
- More ergonomic builders
- Proc macros for tool definitions
- CLI binary for testing

---

## 16. Success Criteria

The implementation will be considered complete when:

1. ✅ All public APIs from Python SDK are ported
2. ✅ All examples run successfully
3. ✅ Integration tests pass against real CLI
4. ✅ Documentation is comprehensive
5. ✅ Error handling is robust
6. ✅ Performance is acceptable (< 10ms overhead vs direct CLI)
7. ✅ Code coverage > 80%
8. ✅ No memory leaks or panics in normal operation
9. ✅ API feels idiomatic to Rust developers
10. ✅ Published to crates.io

---

## Appendix A: Python SDK File Reference

Key files analyzed from `claude-agent-sdk-python`:

- `src/claude_agent_sdk/__init__.py` - Public API exports, tool/server creation
- `src/claude_agent_sdk/types.py` - All type definitions
- `src/claude_agent_sdk/query.py` - Simple query function
- `src/claude_agent_sdk/client.py` - ClaudeSDKClient
- `src/claude_agent_sdk/_errors.py` - Error hierarchy
- `src/claude_agent_sdk/_internal/client.py` - InternalClient
- `src/claude_agent_sdk/_internal/query.py` - Query (control protocol)
- `src/claude_agent_sdk/_internal/transport/__init__.py` - Transport trait
- `src/claude_agent_sdk/_internal/transport/subprocess_cli.py` - SubprocessTransport
- `src/claude_agent_sdk/_internal/message_parser.py` - Message parser
- `examples/quick_start.py` - Basic usage
- `examples/mcp_calculator.py` - Custom tools
- `examples/hooks.py` - Hook examples
- `pyproject.toml` - Dependencies and config

---

## Appendix B: Glossary

- **CLI**: Claude Code command-line interface
- **MCP**: Model Context Protocol - protocol for tool/resource servers
- **SDK MCP Server**: In-process MCP server running within the SDK
- **Hook**: Callback invoked at specific points in the agent loop
- **Transport**: Abstract I/O layer for communicating with Claude
- **Control Protocol**: Bidirectional protocol for managing the Claude session
- **Permission Callback**: User-provided function to approve/deny tool usage
- **Session**: A conversation context with Claude
- **Stream JSON**: Line-delimited JSON format used by CLI

---

**End of Specification**
